#pragma once
#include "commands.h"
#include "preproc.h"

// Default ToString methods
void AstNodeByte_ToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	StringBuilder_Append(builder, "%u", node->value);
}

void AstNodeShort_ToString(STRING_BUILDER* builder, AST_NODE_SHORT* node) {
	StringBuilder_Append(builder, "%u", node->value);
}

void AstNodeInteger_ToString(STRING_BUILDER* builder, AST_NODE_INTEGER* node) {
	StringBuilder_Append(builder, "%u", node->value);
}

void AstNodeInteger_HexToString(STRING_BUILDER* builder, AST_NODE_INTEGER* node) {
	StringBuilder_Append(builder, "%#X", node->value);
}

// Rules:
COMMAND_ARGUMENT_STRING_DATA ARG_STRING_19_DATA = { 19 };
COMMAND_ARGUMENT_TEMPLATE ARG_STRING_19 = { AST_NODE_TYPE_STRING, &ARG_STRING_19_DATA };
COMMAND_ARGUMENT_STRING_DATA ARG_STRING_31_DATA = { 31 };
COMMAND_ARGUMENT_TEMPLATE ARG_STRING_31 = { AST_NODE_TYPE_STRING, &ARG_STRING_31_DATA };
COMMAND_ARGUMENT_STRING_DATA ARG_STRING_79_DATA = { 79 }; // The buffer is for 80 characters, so 79 is the max, because we need room for null terminator.
COMMAND_ARGUMENT_TEMPLATE ARG_STRING_79 = { AST_NODE_TYPE_STRING, &ARG_STRING_79_DATA };

// Data Types:

void TriggerFlagsToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	if (node->value == 1) {
		StringBuilder_AppendString(builder, "TRIGGER_ONCE");
	} else if (node->value == 16) {
		StringBuilder_AppendString(builder, "TRIGGER_START");
	} else {
		AstNodeByte_ToString(builder, node);
	}
}

void ActorStateToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	StringBuilder_AppendString(builder, GetNameFromMacroArray(&g_ActorStateNames, node->value));
}

void TileStateToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	uint8_t value = node->value;

	if (IsIndexInMacroArray(&g_ConveyerTileStateNames, value)) {
		StringBuilder_AppendString(builder, GetNameFromMacroArray(&g_ConveyerTileStateNames, value));
	} else if (IsIndexInMacroArray(&g_TileStateNames, value)) {
		StringBuilder_AppendString(builder, GetNameFromMacroArray(&g_TileStateNames, value));
	} else {
		AstNodeByte_ToString(builder, node);
	}
}

void AnimationFlagsToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	StringBuilder_AppendString(builder, GetNameFromMacroArray(&g_AnimationFlags, node->value));
}

void EnemyFlagsToString(STRING_BUILDER* builder, AST_NODE_INTEGER* node) {
	if (node->value == (1 << 21)) {
		StringBuilder_AppendString(builder, "ENEMYFLAG_NODAMAGE");
	} else {
		AstNodeInteger_HexToString(builder, node);
	}
}

// Enemy:
void EnemyIdToString(STRING_BUILDER* builder, AST_NODE_SHORT* node) {
	if (!node->value) {
		StringBuilder_AppendString(builder, "ENEMY_ALL");
		return;
	}

	StringBuilder_Append(builder, "ENEMY_%u", node->value);
}

void PlatformIdToString(STRING_BUILDER* builder, AST_NODE_SHORT* node) {
	if (!node->value) {
		StringBuilder_AppendString(builder, "PLATFORM_ALL");
		return;
	}

	StringBuilder_Append(builder, "PLATFORM_%u", node->value);
}

void ActorIdToString(STRING_BUILDER* builder, AST_NODE_SHORT* node, bool useAll) {
	if (!node->value) {
		StringBuilder_AppendString(builder, useAll ? "ACTOR_ALL" : "ACTOR_NONE");
		return;
	}

	AstNodeShort_ToString(builder, node);
}

void ActorIdAllToString(STRING_BUILDER* builder, AST_NODE_SHORT* node) {
	ActorIdToString(builder, node, true);
}

void ActorIdNoneToString(STRING_BUILDER* builder, AST_NODE_SHORT* node) {
	ActorIdToString(builder, node, false);
}

void PlayerIdToString(STRING_BUILDER* builder, AST_NODE_BYTE* node) {
	if (!node->value) {
		StringBuilder_AppendString(builder, "MAIN_PLAYER");
		return;
	}

	StringBuilder_Append(builder, "PLAYER_%u", node->value);
}

#pragma warning (disable : 4028)
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_ENEMY_ID_DATA = { EnemyIdToString, nullptr, 0, 65535 }; // 0 = ALL
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ENEMY_ID = { AST_NODE_TYPE_SHORT, &ARG_TYPE_ENEMY_ID_DATA };
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_PLATFORM_ID_DATA = { PlatformIdToString, nullptr, 0, 65535 };  // 0 = ALL
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_PLATFORM_ID = { AST_NODE_TYPE_SHORT, &ARG_TYPE_PLATFORM_ID_DATA };
COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_PLAYER_ID_DATA = { PlayerIdToString, nullptr, 0, 3 };  // 0 - 3 Restriction
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_PLAYER_ID = { AST_NODE_TYPE_BYTE, &ARG_TYPE_PLAYER_ID_DATA };
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_TILE_ID_DATA = { nullptr, nullptr, 0, 65535 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_TILE_ID = { AST_NODE_TYPE_SHORT, &ARG_TYPE_TILE_ID_DATA };
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_PATH_NODE_ID_DATA = { nullptr, nullptr, 0, 65535 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_PATH_NODE_ID = { AST_NODE_TYPE_SHORT, &ARG_TYPE_PATH_NODE_ID_DATA };
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_ACTOR_ID_ALL_DATA = { ActorIdAllToString, nullptr, 0, 65535 }; // Represents a value which could either be enemy or platform. 0 = ALL
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ACTOR_ID_ALL = { AST_NODE_TYPE_SHORT, &ARG_TYPE_ACTOR_ID_ALL_DATA };
COMMAND_ARGUMENT_SHORT_DATA ARG_TYPE_ACTOR_ID_NONE_DATA = { ActorIdNoneToString, nullptr, 0, 65535 }; // Represents a value which could either be enemy or platform. 0 = NONE
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ACTOR_ID_NONE = { AST_NODE_TYPE_SHORT, &ARG_TYPE_ACTOR_ID_NONE_DATA };

COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_TRIGGER_FLAGS_DATA = { TriggerFlagsToString, nullptr, 0, 255 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_TRIGGER_FLAGS = { AST_NODE_TYPE_BYTE, &ARG_TYPE_TRIGGER_FLAGS_DATA };
COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_ACTOR_STATE_DATA = { ActorStateToString, nullptr, 1, 9 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ACTOR_STATE = { AST_NODE_TYPE_BYTE, &ARG_TYPE_ACTOR_STATE_DATA };
COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_TILE_FLAGS_DATA = { TileStateToString, nullptr, 0, 47 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_TILE_FLAGS = { AST_NODE_TYPE_BYTE, &ARG_TYPE_TILE_FLAGS_DATA };
COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_ANIMATION_FLAGS_DATA = { AnimationFlagsToString, nullptr, 0, 3 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ANIMATION_FLAGS = { AST_NODE_TYPE_BYTE, &ARG_TYPE_ANIMATION_FLAGS_DATA };
COMMAND_ARGUMENT_INTEGER_DATA ARG_TYPE_ENEMY_FLAGS_DATA = { EnemyFlagsToString, nullptr, 0, UINT32_MAX };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_ENEMY_FLAGS = { AST_NODE_TYPE_INTEGER, &ARG_TYPE_ENEMY_FLAGS_DATA };
COMMAND_ARGUMENT_INTEGER_DATA ARG_TYPE_PLATFORM_FLAGS_DATA = { nullptr, AstNodeInteger_HexToString, 0, UINT32_MAX };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_PLATFORM_FLAGS = { AST_NODE_TYPE_INTEGER, &ARG_TYPE_PLATFORM_FLAGS_DATA };

COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_COUNTER_DATA = { nullptr, nullptr, 0, NUMBER_OF_COUNTERS - 1 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_COUNTER = { AST_NODE_TYPE_BYTE, &ARG_TYPE_COUNTER_DATA };
COMMAND_ARGUMENT_BYTE_DATA ARG_TYPE_FLAG_DATA = { nullptr, nullptr, 0, NUMBER_OF_FLAGS - 1 };
COMMAND_ARGUMENT_TEMPLATE ARG_TYPE_FLAG = { AST_NODE_TYPE_BYTE, &ARG_TYPE_FLAG_DATA };
#pragma warning (default : 4028)

// Command Defines:
#pragma warning (disable : 4047)
COMMAND_ARGUMENT CDEBUG_ARGUMENT_TYPES[] = { AST_NODE_TYPE_SHORT, AST_NODE_TYPE_SHORT };
COMMAND_ARGUMENT HINT_ARGUMENT_TYPES[] = { AST_NODE_TYPE_SHORT };
COMMAND_ARGUMENT SFX_NOCLIP_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_BYTE, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT ANIMATEFROG_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, AST_NODE_TYPE_BYTE, &ARG_TYPE_ANIMATION_FLAGS, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT KILLFROG_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, AST_NODE_TYPE_BYTE };
COMMAND_ARGUMENT STOPSOUND_ARGUMENT_TYPES[] = { &ARG_STRING_31 };
COMMAND_ARGUMENT PLAYSOUND_ARGUMENT_TYPES[] = { &ARG_STRING_31, &ARG_TYPE_ACTOR_ID_NONE };
COMMAND_ARGUMENT SPRING_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SETSTARTTILE_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID };
COMMAND_ARGUMENT TELEPORT_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SETTILE_ARGUMENT_TYPES[] = { &ARG_TYPE_TILE_ID, &ARG_TYPE_TILE_FLAGS };
COMMAND_ARGUMENT SHAKECAMERA_ARGUMENT_TYPES[] = { AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT CHANGEFROG_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_STRING_19 };
COMMAND_ARGUMENT COLLAPSE_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SET_COUNTER_ARGUMENT_TYPES[] = { &ARG_TYPE_COUNTER, AST_NODE_TYPE_SHORT };
COMMAND_ARGUMENT DEC_COUNTER_ARGUMENT_TYPES[] = { &ARG_TYPE_COUNTER };
COMMAND_ARGUMENT INC_COUNTER_ARGUMENT_TYPES[] = { &ARG_TYPE_COUNTER };
COMMAND_ARGUMENT SCALEPLATSPEED_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SCALEENEMYSPEED_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SFX_PLACEHOLDER_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_BYTE, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT SFX_ENEMY_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, AST_NODE_TYPE_BYTE, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT RESETFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_FLAG };
COMMAND_ARGUMENT SETFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_FLAG };
COMMAND_ARGUMENT FOG_ARGUMENT_TYPES[] = { AST_NODE_TYPE_BYTE, AST_NODE_TYPE_BYTE, AST_NODE_TYPE_BYTE, AST_NODE_TYPE_SHORT, AST_NODE_TYPE_SHORT };
COMMAND_ARGUMENT HOP_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_TILE_ID };
COMMAND_ARGUMENT CHANGELEVEL_ARGUMENT_TYPES[] = { AST_NODE_TYPE_BYTE, AST_NODE_TYPE_BYTE };
COMMAND_ARGUMENT MOVEPLAT_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, &ARG_TYPE_PATH_NODE_ID };
COMMAND_ARGUMENT MOVEENEMY_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_PATH_NODE_ID };
COMMAND_ARGUMENT SETPLATFORM_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, &ARG_TYPE_ACTOR_STATE };
COMMAND_ARGUMENT SETENEMY_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_ACTOR_STATE };
COMMAND_ARGUMENT ANIMATEACTOR_ARGUMENT_TYPES[] = { &ARG_TYPE_ACTOR_ID_ALL, AST_NODE_TYPE_BYTE, &ARG_TYPE_ANIMATION_FLAGS, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT RESETPLATFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, &ARG_TYPE_PLATFORM_FLAGS };
COMMAND_ARGUMENT SETPLATFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, &ARG_TYPE_PLATFORM_FLAGS };
COMMAND_ARGUMENT RESETENEMYFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_ENEMY_FLAGS };
COMMAND_ARGUMENT SETENEMYFLAG_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_ENEMY_FLAGS };
COMMAND_ARGUMENT DEBUG_ARGUMENT_TYPES[] = { &ARG_STRING_79 };
COMMAND_ARGUMENT IF_ARGUMENT_TYPES[] = { AST_NODE_TYPE_TRIGGER, AST_NODE_TYPE_BLOCK };
COMMAND_ARGUMENT ON_ARGUMENT_TYPES[] = { AST_NODE_TYPE_TRIGGER, &ARG_TYPE_TRIGGER_FLAGS, AST_NODE_TYPE_BLOCK };
#pragma warning (default : 4047)

// Registry of different commands.
REGISTERED_COMMAND g_RegisteredCommands[REGISTERED_COMMAND_COUNT] = {
	{C_DEBUG, COMMAND_TYPE_EVENT, "_Internal_SetDebugLine", 2, CDEBUG_ARGUMENT_TYPES},
	{EV_HINT, COMMAND_TYPE_EVENT, "Hint", 1, HINT_ARGUMENT_TYPES},
	{EV_SFX_P_NOCLIP, COMMAND_TYPE_EVENT, "SfxOnPNoClip", 6, SFX_NOCLIP_ARGUMENT_TYPES},
	{EV_POKEFROGS, COMMAND_TYPE_EVENT, "PokeFrogs", 0, nullptr},
	{EV_ENDLEVEL, COMMAND_TYPE_EVENT, "EndLevel", 0, nullptr},
	{EV_RESETSCRIPT, COMMAND_TYPE_EVENT, "ResetScript", 0, nullptr},
	{EV_ANIMATEFROG, COMMAND_TYPE_EVENT, "AnimatePlayer", 4, ANIMATEFROG_ARGUMENT_TYPES},
	{EV_KILLFROG, COMMAND_TYPE_EVENT, "KillFrog", 2, KILLFROG_ARGUMENT_TYPES},
	{EV_STOPSOUND, COMMAND_TYPE_EVENT, "StopSound", 1, STOPSOUND_ARGUMENT_TYPES}, 
	{EV_PLAYSOUND, COMMAND_TYPE_EVENT, "PlaySound", 2, PLAYSOUND_ARGUMENT_TYPES},
	{EV_SPRING_P, COMMAND_TYPE_EVENT, "SpringP", 4, SPRING_ARGUMENT_TYPES},
	{EV_SETSTARTTILE_P, COMMAND_TYPE_EVENT, "SetStartTilePlayer", 1, SETSTARTTILE_ARGUMENT_TYPES},
	{EV_TELEPORT_P, COMMAND_TYPE_EVENT, "TeleportPlayer", 3, TELEPORT_ARGUMENT_TYPES},
	{EV_SETTILE_P, COMMAND_TYPE_EVENT, "SetTileState", 2, SETTILE_ARGUMENT_TYPES},
	{EV_SHAKECAMERA, COMMAND_TYPE_EVENT, "ShakeCamera", 2, SHAKECAMERA_ARGUMENT_TYPES},
	{EV_CHANGEFROG, COMMAND_TYPE_EVENT, "ChangeFrog", 2, CHANGEFROG_ARGUMENT_TYPES},
	{EV_COLLAPSE_PLAT, COMMAND_TYPE_EVENT, "Collapse", 2, COLLAPSE_ARGUMENT_TYPES},
	{EV_SET_COUNTER, COMMAND_TYPE_EVENT, "SetCounter", 2, SET_COUNTER_ARGUMENT_TYPES},
	{EV_DEC_COUNTER, COMMAND_TYPE_EVENT, "DecCounter", 1, DEC_COUNTER_ARGUMENT_TYPES},
	{EV_INC_COUNTER, COMMAND_TYPE_EVENT, "IncCounter", 1, INC_COUNTER_ARGUMENT_TYPES},
	{EV_SCALEPLATSPEED, COMMAND_TYPE_EVENT, "ScalePlatformSpeed", 2, SCALEPLATSPEED_ARGUMENT_TYPES},
	{EV_SCALENMESPEED, COMMAND_TYPE_EVENT, "ScaleEnemySpeed", 2, SCALEENEMYSPEED_ARGUMENT_TYPES},
//	{EV_HURTFROG, COMMAND_TYPE_EVENT, nullptr, 0, nullptr}, // Enum exists, but has no behavior.
	{EV_SFX_PLACEHOLDER, COMMAND_TYPE_EVENT, "SfxOnPlaceholder", 6, SFX_PLACEHOLDER_ARGUMENT_TYPES},
	{EV_SFX_ENEMY, COMMAND_TYPE_EVENT, "SFXOnEnemy", 6, SFX_ENEMY_ARGUMENT_TYPES},
	{EV_RESETFLAG, COMMAND_TYPE_EVENT, "ResetToggle", 1, RESETFLAG_ARGUMENT_TYPES},
	{EV_SETFLAG, COMMAND_TYPE_EVENT, "SetToggle", 1, SETFLAG_ARGUMENT_TYPES},
	{EV_CAMEOMODE_OFF, COMMAND_TYPE_EVENT, "CameoModeOff", 0, nullptr},
	{EV_CAMEOMODE_ON, COMMAND_TYPE_EVENT, "CameoModeOn", 0, nullptr},
	{EV_NO_FOG, COMMAND_TYPE_EVENT, "NoFog", 0, nullptr},
	{EV_FOG, COMMAND_TYPE_EVENT, "Fog", 5, FOG_ARGUMENT_TYPES},
	{EV_HOP, COMMAND_TYPE_EVENT, "Hop", 2, HOP_ARGUMENT_TYPES},
	{EV_CHANGELEVEL, COMMAND_TYPE_EVENT, "ChangeLevel", 2, CHANGELEVEL_ARGUMENT_TYPES},
	{EV_CHANGEVOLUME, COMMAND_TYPE_EVENT, "ChangeVolume", 0, nullptr},
	{EV_MOVEPLAT, COMMAND_TYPE_EVENT, "MovePlatform", 2, MOVEPLAT_ARGUMENT_TYPES},
	{EV_MOVEENEMY, COMMAND_TYPE_EVENT, "MoveEnemy", 2, MOVEENEMY_ARGUMENT_TYPES},
	{EV_SETPLATFORM, COMMAND_TYPE_EVENT, "SetPlatform", 2, SETPLATFORM_ARGUMENT_TYPES},
	{EV_SETENEMY, COMMAND_TYPE_EVENT, "SetEnemy", 2, SETENEMY_ARGUMENT_TYPES},
	{EV_ANIMATEACTOR, COMMAND_TYPE_EVENT, "Animate", 4, ANIMATEACTOR_ARGUMENT_TYPES},
	{EV_RESETPLATFLAG, COMMAND_TYPE_EVENT, "ResetPlatformFlag" , 2, RESETPLATFLAG_ARGUMENT_TYPES},
	{EV_SETPLATFLAG, COMMAND_TYPE_EVENT, "SetPlatformFlag", 2, SETPLATFLAG_ARGUMENT_TYPES},
	{EV_RESETENEMYFLAG, COMMAND_TYPE_EVENT, "ResetEnemyFlag", 2, RESETENEMYFLAG_ARGUMENT_TYPES},
	{EV_SETENEMYFLAG, COMMAND_TYPE_EVENT, "SetEnemyFlag", 2, SETENEMYFLAG_ARGUMENT_TYPES},
	{EV_DEBUG, COMMAND_TYPE_EVENT, "Debug", 1, DEBUG_ARGUMENT_TYPES},
	{EV_IF, COMMAND_TYPE_EVENT, "if", 2, IF_ARGUMENT_TYPES},
	{EV_ON, COMMAND_TYPE_EVENT, "on", 3, ON_ARGUMENT_TYPES}
};


/* Triggers */

#pragma warning (disable : 4047)
COMMAND_ARGUMENT NOT_ARGUMENT_TYPES[] = { AST_NODE_TYPE_TRIGGER };
COMMAND_ARGUMENT OR_ARGUMENT_TYPES[] = { AST_NODE_TYPE_TRIGGER, AST_NODE_TYPE_TRIGGER };
COMMAND_ARGUMENT AND_ARGUMENT_TYPES[] = { AST_NODE_TYPE_TRIGGER, AST_NODE_TYPE_TRIGGER };
COMMAND_ARGUMENT FROGONPATH_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_ENEMY_ID };
COMMAND_ARGUMENT LEVELOPEN_ARGUMENT_TYPES[] = { AST_NODE_TYPE_BYTE, AST_NODE_TYPE_BYTE };
COMMAND_ARGUMENT FROGISDEAD_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID };
COMMAND_ARGUMENT COUNTEREQUALS_ARGUMENT_TYPES[] = { &ARG_TYPE_COUNTER, AST_NODE_TYPE_SHORT };
COMMAND_ARGUMENT FLAGSET_ARGUMENT_TYPES[] = { &ARG_TYPE_FLAG };
COMMAND_ARGUMENT WAIT_ARGUMENT_TYPES[] = { AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT PLATATNODE_ARGUMENT_TYPES[] = { &ARG_TYPE_PLATFORM_ID, &ARG_TYPE_PATH_NODE_ID };
COMMAND_ARGUMENT ENEMYATNODE_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_PATH_NODE_ID };
COMMAND_ARGUMENT RANDOMWAIT_ARGUMENT_TYPES[] = { AST_NODE_TYPE_DECIMAL, AST_NODE_TYPE_DECIMAL };
COMMAND_ARGUMENT FROGONPLATFORM_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_PLATFORM_ID };
COMMAND_ARGUMENT FROGONTILE_ARGUMENT_TYPES[] = { &ARG_TYPE_PLAYER_ID, &ARG_TYPE_TILE_ID };
COMMAND_ARGUMENT ENEMYONTILE_ARGUMENT_TYPES[] = { &ARG_TYPE_ENEMY_ID, &ARG_TYPE_TILE_ID };
#pragma warning (default : 4047)

REGISTERED_COMMAND g_RegisteredTriggers[REGISTERED_TRIGGER_COUNT] = {
	{TR_NOT, COMMAND_TYPE_TRIGGER, "NOT", 1, NOT_ARGUMENT_TYPES},
	{TR_OR, COMMAND_TYPE_TRIGGER, "OR", 2, OR_ARGUMENT_TYPES},
	{TR_AND, COMMAND_TYPE_TRIGGER, "AND", 2, AND_ARGUMENT_TYPES},
	{TR_ONPATH, COMMAND_TYPE_TRIGGER, "FrogOnPath", 2, FROGONPATH_ARGUMENT_TYPES},
	{TR_LEVELISOPEN, COMMAND_TYPE_TRIGGER, "LevelOpen", 2, LEVELOPEN_ARGUMENT_TYPES},
	{TR_FROGISDEAD, COMMAND_TYPE_TRIGGER, "FrogIsDead", 1, FROGISDEAD_ARGUMENT_TYPES},
	{TR_COUNTEREQUALS, COMMAND_TYPE_TRIGGER, "CounterEquals", 2, COUNTEREQUALS_ARGUMENT_TYPES},
	{TR_FLAGSET, COMMAND_TYPE_TRIGGER, "IsFlagSet", 1, FLAGSET_ARGUMENT_TYPES},
	{TR_WAIT, COMMAND_TYPE_TRIGGER, "Wait", 1, WAIT_ARGUMENT_TYPES},
	{TR_PLATATFLAG, COMMAND_TYPE_TRIGGER, "PlatformAtPathNode", 2, PLATATNODE_ARGUMENT_TYPES},
	{TR_ENEMYATFLAG, COMMAND_TYPE_TRIGGER, "EnemyAtPathNode", 2, ENEMYATNODE_ARGUMENT_TYPES},
	{TR_RANDOMWAIT, COMMAND_TYPE_TRIGGER, "RandomWait", 2, RANDOMWAIT_ARGUMENT_TYPES},
	{TR_FROGONPLATFORM, COMMAND_TYPE_TRIGGER, "FrogOnPlatform", 2, FROGONPLATFORM_ARGUMENT_TYPES},
	{TR_FROGONTILE, COMMAND_TYPE_TRIGGER, "FrogOnTile", 2, FROGONTILE_ARGUMENT_TYPES},
	{TR_ENEMYONTILE, COMMAND_TYPE_TRIGGER, "EnemyOnTile", 2, ENEMYONTILE_ARGUMENT_TYPES}
};

typedef REGISTERED_COMMAND REGISTERED_COMMAND_ARRAY[];

REGISTERED_COMMAND_ARRAY* GetRegisteredCommands(COMMAND_TYPE type) {
	switch (type) {
	case COMMAND_TYPE_EVENT:
		return &g_RegisteredCommands;
	case COMMAND_TYPE_TRIGGER:
		return &g_RegisteredTriggers;
	default:
		return nullptr;
	}
}

int GetRegisteredCommandCount(COMMAND_TYPE type) {
	switch (type) {
	case COMMAND_TYPE_EVENT:
		return REGISTERED_COMMAND_COUNT;
	case COMMAND_TYPE_TRIGGER:
		return REGISTERED_TRIGGER_COUNT;
	default:
		return 0;
	}
}

COMMAND_TYPE GetCommandTypeFromASTNodeType(AST_NODE_TYPE type) {
	switch (type) {
	case AST_NODE_TYPE_EVENT:
		return COMMAND_TYPE_EVENT;
	case AST_NODE_TYPE_TRIGGER:
		return COMMAND_TYPE_TRIGGER;
	default:
		return -1;
	}
}

REGISTERED_COMMAND* FindCommandByNameFrom(REGISTERED_COMMAND_ARRAY *commands, int command_length, const char* name) {
	if (commands == nullptr || name == nullptr)
		return nullptr;

	for (int i = 0; i < command_length; i++)
		if ((*commands)[i].mnemonic && !strcasecmp((*commands)[i].mnemonic, name))
			return &(*commands)[i];

	return nullptr;
}

REGISTERED_COMMAND* FindCommandByOpcodeFrom(REGISTERED_COMMAND_ARRAY *commands, int command_length, uint8_t opcode) {
	if (commands == nullptr)
		return nullptr;

	for (int i = 0; i < command_length; i++)
		if ((*commands)[i].opcode == opcode)
			return &(*commands)[i];

	return nullptr;
}

REGISTERED_COMMAND* FindCommandByName(const char* name, COMMAND_TYPE type) {
	return FindCommandByNameFrom(GetRegisteredCommands(type), GetRegisteredCommandCount(type), name);
}

REGISTERED_COMMAND* FindCommandByOpcode(uint8_t opcode, COMMAND_TYPE type) {
	return FindCommandByOpcodeFrom(GetRegisteredCommands(type), GetRegisteredCommandCount(type), opcode);
}

bool IsSpaceShownForCommand(const REGISTERED_COMMAND* command) {
	return command->type == COMMAND_TYPE_EVENT && (command->opcode == EV_ON || command->opcode == EV_IF);
}

bool AreParenthesisShownForCommand(const REGISTERED_COMMAND* command) {
	return command->type != COMMAND_TYPE_EVENT || (command->opcode != EV_ON && command->opcode != EV_IF);
}

bool CommandIsArgumentDataPresent(const COMMAND_ARGUMENT* argument) {
	return argument->argument_type & 0xFFFFFF00U;
}

AST_NODE_TYPE CommandGetArgumentType(const COMMAND_ARGUMENT* argument) {
	return CommandIsArgumentDataPresent(argument) ? argument->data->argument_type : argument->argument_type;
}

void* CommandGetArgumentData(const COMMAND_ARGUMENT* argument) {
	return CommandIsArgumentDataPresent(argument) ? argument->data->extra_data : nullptr;
}

void PrintCommandSignature(const REGISTERED_COMMAND* command) {
	printf("%s", command->mnemonic);
	printf("(");

	for (int i = 0; i < command->argument_count; i++) {
		if (i > 0)
			printf(", ");
		printf("%s", GetNodeTypeName(CommandGetArgumentType(&command->argument_types[i])));
	}

	printf(")");
}